---
title: Building an SSL REST API
tagline: For Fun and Profit
layout: post
tags: SSL REST
---

Recently I've been thinking about the internet of things, mostly in the context of the Raspberry Pi computers that I
have. One of the common problems of the internet of things is the ability to authenticate each individual device to some
tracking service, e.g. [a service which allows you to access the device's functionality from the
internet](/blog/2015/01/04/raspberry-pi-music-server.html). I believe that using SSL client certificates with a REST API
would be one of the most secure ways to authenticate devices to some central service.

<!--more-->

SSL client certificates are, put simply, a way for a computer to authenticate itself to a server in a similar way that
servers running protocols such as HTTPS authenticate themselves to web browsers. Despite being much more secure than
passwords, It has not received much uptake, due in part to requiring extremely obtuse UIs to properly configure, and
problems inherent in securely authenticating from your computer, phone, and tablet without sharing the certificates in
an insecure way or storing them on a central server. This makes them fundamentally a bad fit for authenticating users,
but a good fit for authenticating devices. For instance, once your [Nest thermostat](https://nest.com/thermostat) is
associated with your account, you don't want to store your email and password on the device to be sent every time the
thermostat needs to check in with the central server, since the email and password would have to be stored in the clear
on the device, and a compromised device implies a compromised account.

The next simplest option is to issue each device an ID of some kind, to be communicated securely with the server,
however this is essentially identical to issuing an SSL client certificate to each device, provided you pin the
certificate to the user's account. If you're using a REST API and a web server that supports client certificates, this
allows you to get a lot of device identification "for free" built into your API. Trading a token for a client
certificate does not necessarily have any obvious security gains (since your API already uses conventional HTTPS,
*right?*), however as the internet of things evolves, devices may gain some discrete encryption chip which allows
performing encryption away from the processor (be it built into the circuit board or external, such as on a smart card),
in which case using client certificates definitely would have an advantage. Plus they're damn cool.

The other use case for using client certificates is in publicly accessible APIs. For a good example of a well documented
REST API, see [Stripe's API Documentation](https://stripe.com/docs/api?lang=curl#errors); there basic HTTP
authentication is used, with the API key specified in the username. That could easily be replaced with `--cert api.crt`,
which also allows easy swapping of API keys if necessary.

## Proof of Concept

To prove that this could easily be done, I started up a new instance of NGINX with SSL and configured it to accept
client certificates and forward them using the `X-SSL-Client-Cert` header and a few other headers for convenience.
I set up NGINX to reverse proxy to a simple [Flask](http://flask.pocoo.org) web application to extract the headers that
NGINX would set for the certificate and show them to me. The NGINX config and the web app are below:

{% gist rchowe/2f00d3f5ab23e2299da2 %}
{% gist rchowe/5675ada35157122f98a5 %}

In my API, I would likely use `X-SSL-Verified` to check that NGINX had confirmed the certificate, and use
`X-SSL-Client-Cert` to ensure that the certificate is valid for the user's account. I'm a little wary of using the
distinguished name of the cert, because I feel as though some misconfiguration could be used to exploit that.

And it works! I'm using a self-signed server certificate for development, which is why I need to use the `-k` insecure
option of `curl`, however the principle is the same.

{% gist rchowe/4cae88707fb98a6f8349 %}

which outputs

{% gist rchowe/424a7333e763e72f938b %}

## A More Real Example

Consider a REST API with the example actions. `POST /action` is some secure action that we want to protect, and

| Action         | Description                                            | Secure |
| -------------- | ------------------------------------------------------ | ------ |
| `GET /`        | Display available methods.                             | No     |
| `POST /sign`   | Obtain a new certificate signed by the Client Cert CA. | No     |
| `POST /action` | Perform some secured action.                           | Yes    |
